import javafx.util.Pair;

import java.util.*;

/**
 * Created by gejing on 2/27/16.
 */
public class ProbabilisticProblem {
    private double[][] T;  //transition model
    private double[][] Or; //sensor model for red
    private double[][] Og; //sensor model for green
    private double[][] Ob; //sensor model for blue
    private double[][] Oy; //sensor model for yellow

    private Maze maze;
    private int tileNumber;

    Map<Integer, Pair<Integer, Integer>> index = new HashMap<>();

    private List<Pair<Integer, Integer>> actualPath = new ArrayList<>(); //record actual path the robot past.
    private List<Pair<Integer, Integer>> likelyPath = new ArrayList<>(); //record most likely path the robot past.
    private double[][] probabilityDistribution;                          //probability distribution of each state.
    private double[][] smoothyDistribution;                              //probability distribution generated by forward-backward algorithm.

    public ProbabilisticProblem() {
        maze = Maze.readFromFile("simple.maz");
        if (maze == null) throw new RuntimeException("maze is null");
        int indexNumber = 0;
        for (int y = 0; y < maze.height; y++) {
            for (int x = 0; x < maze.width; x++) {
                if (maze.isLegal(x, y)) {
                    indexNumber++;
                    index.put(indexNumber, new Pair<>(x, y));
                }
            }
        }
        tileNumber = indexNumber;

        T = new double[indexNumber][];
        Ob = new double[indexNumber][];
        Og = new double[indexNumber][];
        Or = new double[indexNumber][];
        Oy = new double[indexNumber][];

        for (int i = 0; i < indexNumber; i++) {
            Pair<Integer, Integer> position1 = index.get(i + 1);
            T[i] = new double[indexNumber];
            Or[i] = new double[indexNumber];
            Og[i] = new double[indexNumber];
            Ob[i] = new double[indexNumber];
            Oy[i] = new double[indexNumber];

            for (int j = 0; j < indexNumber; j++) {
                //generate transition model:
                Pair<Integer, Integer> position2 = index.get(j + 1);
                T[i][j] = getTransitionProbability(position1, position2);
                //generate sensor model for colors red, green, blue, yellow:
                if (i == j) {
                    Or[i][j] = getSensorProbability(position1, 'r');
                    Og[i][j] = getSensorProbability(position1, 'g');
                    Ob[i][j] = getSensorProbability(position1, 'b');
                    Oy[i][j] = getSensorProbability(position1, 'y');
                } else {
                    Or[i][j] = 0;
                    Og[i][j] = 0;
                    Ob[i][j] = 0;
                    Oy[i][j] = 0;
                }
            }
        }
    }

    public void doMoves(int[][] steps) {
        probabilityDistribution = new double[steps.length + 1][];
        double[] firstDistribution = new double[tileNumber];
        for (int i = 0; i < tileNumber; i++) {
            firstDistribution[i] = 1.0 / tileNumber;
        }
        probabilityDistribution[0] = firstDistribution;

        //choose initial position randomly:
        int initPosition = new Random().nextInt(tileNumber) + 1;
        Pair<Integer, Integer> position = index.get(initPosition);
        actualPath.add(position);

        char[] sensorReadings = new char[steps.length];

        // move the robot and generate probability distribution by forward algorithm.
        for (int i = 0; i < steps.length; i++) {
            if (maze.isLegal(position.getKey() + steps[i][0], position.getValue() + steps[i][1])) {
                position = new Pair<>(position.getKey() + steps[i][0], position.getValue() + steps[i][1]);
            }
            actualPath.add(position);
            sensorReadings[i] = getTileColor(position);
            probabilityDistribution[i + 1] = forward(probabilityDistribution[i], getTileColor(position));
        }

        // get smoothy probability distribution by forward-backward algorithm.
        this.smoothyDistribution = forwardBackward(firstDistribution, sensorReadings);
        // get most likely path using smoothy distribution:
        this.likelyPath = getMostLikelyPath(this.smoothyDistribution);
    }

    public void printReport(String motions) {
        System.out.println("the maze this test used :");
        System.out.println(maze);
        System.out.println("the motions robot taken :\n" + motions);
        System.out.println("the actual path robot move is:");
        for (Pair<Integer, Integer> p : actualPath) {
            System.out.print("(" + p.getKey() + "," + p.getValue() + ")");
        }
        System.out.println();
        System.out.println("the most likely path we guess is :");
        for (Pair<Integer, Integer> p : likelyPath) {
            System.out.print("(" + p.getKey() + "," + p.getValue() + ")");
        }
        System.out.println();
        System.out.println("\nthe smoothy distribution is:");
        printDistribution(this.smoothyDistribution);
        System.out.println("\nthe filter distribution is:");
        printDistribution(this.probabilityDistribution);
    }

    private void printDistribution(double[][] distribution) {
        for (int i = 0; i < distribution[0].length; i++) {
            System.out.print("_____________");
        }
        System.out.println();
        System.out.printf("| steps |");
        for (int i = 1; i <= distribution[0].length; i++) {
            System.out.printf("   (%d,%d)   |", index.get(i).getKey(), index.get(i).getValue());
        }
        System.out.println();
        for (int i = 0; i < distribution.length; i++) {
            System.out.printf("| step%d | ", i);
            for (int j = 0; j < distribution[0].length; j++) {
                System.out.printf("%.7f | ", distribution[i][j]);
            }
            System.out.println();
        }
    }

    private List<Pair<Integer, Integer>> getMostLikelyPath(double[][] distribution) {
        List<Pair<Integer, Integer>> path = new ArrayList<>();

        for (int i = 0; i < distribution.length; i++) {
            int maxIndex = 0;
            double maxValue = 0;
            for (int j = 0; j < distribution[0].length; j++) {
                if (distribution[i][j] > maxValue) {
                    maxValue = distribution[i][j];
                    maxIndex = j;
                }
            }
            path.add(this.index.get(maxIndex + 1));
        }

        return path;
    }

    private double[][] forwardBackward(double[] prior, char[] sensorReadings) {
        double[][] forwardDistribution = new double[sensorReadings.length + 1][];
        double[][] smoothDistribution = new double[sensorReadings.length + 1][];
        double[] backwardMessage = new double[prior.length];

        //initial forward msg and backward msg:
        forwardDistribution[0] = prior;
        for (int i = 0; i < backwardMessage.length; i++) {
            backwardMessage[i] = 1;
        }

        for (int i = 0; i < sensorReadings.length; i++) {
            forwardDistribution[i + 1] = forward(forwardDistribution[i], sensorReadings[i]);
        }

        for (int i = sensorReadings.length; i > 0; i--) {
            smoothDistribution[i] = MatrixTools.vectorNormalize(MatrixTools.vectorMultiple(forwardDistribution[i], backwardMessage));
            backwardMessage = backward(backwardMessage, sensorReadings[i - 1]);
        }
        smoothDistribution[0] = new double[prior.length];
        return smoothDistribution;
    }

    private double[] forward(double[] lastOne, char color) {
        double[][] O = getSensorModelByColor(color);
        double[][] line = new double[1][];
        line[0] = lastOne;
        double[][] result = MatrixTools.multiple(MatrixTools.multiple(O, MatrixTools.transpose(T)), MatrixTools.transpose(line));
        return MatrixTools.transpose(MatrixTools.normalize(result))[0];
    }

    private double[] backward(double[] bv, char color) {
        double[][] O = getSensorModelByColor(color);
        double[][] line = new double[1][];
        line[0] = bv;
        double[][] result = MatrixTools.multiple(MatrixTools.multiple(T, O), MatrixTools.transpose(line));
        return MatrixTools.transpose(result)[0];
    }

    private double getTransitionProbability(Pair<Integer, Integer> p1, Pair<Integer, Integer> p2) {
        int x1 = p1.getKey(),
                y1 = p1.getValue(),
                x2 = p2.getKey(),
                y2 = p2.getValue();
        int walls = 0;
        if (!maze.isLegal(x1 + 1, y1)) walls++;
        if (!maze.isLegal(x1 - 1, y1)) walls++;
        if (!maze.isLegal(x1, y1 + 1)) walls++;
        if (!maze.isLegal(x1, y1 - 1)) walls++;

        if (Math.abs(x2 - x1 + y2 - y1) == 1) return 0.25;
        if (p1.equals(p2)) return walls / 4.0;
        return 0;
    }

    private double getSensorProbability(Pair<Integer, Integer> position, char color) {
        int x = position.getKey();
        int y = position.getValue();
        char trueColor = maze.getChar(x, y);
        if (trueColor == color) {
            return 0.88;
        }
        return 0.04;
    }

    private char getTileColor(Pair<Integer, Integer> position) {
        List<Character> colors = new ArrayList<>();
        colors.add('r');
        colors.add('g');
        colors.add('b');
        colors.add('y');
        int rand = new Random().nextInt(100);
        char trueColor = maze.getChar(position.getKey(), position.getValue());
        int i = colors.indexOf(trueColor);
        if (rand > 87 && rand < 92) {
            i = (i + 1) % 4;
        } else if (rand > 91 && rand < 96) {
            i = (i + 2) % 4;
        } else if (rand > 95 && rand < 100) {
            i = (i + 3) % 4;
        }
        return colors.get(i);
    }

    private double[][] getSensorModelByColor(char color) {
        switch (color) {
            case 'r':
                return Or;
            case 'g':
                return Og;
            case 'b':
                return Ob;
            case 'y':
                return Oy;
            default:
                throw new RuntimeException("wrong color");
        }
    }

    public static void main(String[] args) {
        ProbabilisticProblem probabilisticProblem = new ProbabilisticProblem();
        int[][] steps = {Maze.EAST, Maze.SOUTH, Maze.WEST, Maze.WEST, Maze.NORTH};
        probabilisticProblem.doMoves(steps);
        probabilisticProblem.printReport("eswwn");
    }
}
